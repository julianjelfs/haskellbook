
==================== FINAL INTERFACE ====================
2017-11-25 10:53:39.6459061 UTC

interface chapter15-0.1.0.0-Jcnq64q4x8L3hVPjY2Ehph:Lib 8002
  interface hash: 1b531cdc582a08f82f77f45181beae72
  ABI hash: b889df9a4b7ee41d296afde0717b16d5
  export-list hash: f9aa5939e6b0f45224d2def7fe843f69
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 6dc482abc3b5fa230126311d37f8c87b
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.someFunc
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Monoid 57d0116342e60080b20e7d5f9e1248f9
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.Show eca5834daba3b6a2bbbe64ab52056707
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  base-4.9.1.0:System.IO 5daf3f384209c11d9566e3409af8ec5d
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
4c43ce544bacc80471ed30ee30e1adf0
  $fEqFirst' :: GHC.Classes.Eq a => GHC.Classes.Eq (Lib.First' a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Lib.First' a)
                  (Lib.$fEqFirst'_$c== @ a $dEq)
                  (Lib.$fEqFirst'_$c/= @ a $dEq) -}
4c43ce544bacc80471ed30ee30e1adf0
  $fEqFirst'_$c/= ::
    GHC.Classes.Eq a => Lib.First' a -> Lib.First' a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fEqFirst'_$c/=1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Lib.N:First'[0]) <a>_N
                 ->_R Sym (Lib.N:First'[0]) <a>_N
                 ->_R <GHC.Types.Bool>_R) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fEqFirst'_$c/=1 ::
    GHC.Classes.Eq a =>
    Lib.Optional a -> Lib.Optional a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Lib.Optional a)
                   (b :: Lib.Optional a) ->
                 case a1 of wild {
                   Lib.Nada
                   -> case b of wild1 {
                        Lib.Nada -> GHC.Types.False Lib.Only ipv -> GHC.Types.True }
                   Lib.Only a2
                   -> case b of wild1 {
                        Lib.Nada -> GHC.Types.True
                        Lib.Only b1
                        -> case GHC.Classes.== @ a $dEq a2 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
4c43ce544bacc80471ed30ee30e1adf0
  $fEqFirst'_$c== ::
    GHC.Classes.Eq a => Lib.First' a -> Lib.First' a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fEqFirst'_$c==1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Lib.N:First'[0]) <a>_N
                 ->_R Sym (Lib.N:First'[0]) <a>_N
                 ->_R <GHC.Types.Bool>_R) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fEqFirst'_$c==1 ::
    GHC.Classes.Eq a =>
    Lib.Optional a -> Lib.Optional a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: Lib.Optional a)
                   (ds1 :: Lib.Optional a) ->
                 case ds of wild {
                   Lib.Nada
                   -> case ds1 of wild1 {
                        Lib.Nada -> GHC.Types.True Lib.Only ipv -> GHC.Types.False }
                   Lib.Only a1
                   -> case ds1 of wild1 {
                        Lib.Nada -> GHC.Types.False
                        Lib.Only b1 -> GHC.Classes.== @ a $dEq a1 b1 } }) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fEqOptional :: GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Optional a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Lib.Optional a)
                  (Lib.$fEqFirst'_$c==1 @ a $dEq)
                  (Lib.$fEqFirst'_$c/=1 @ a $dEq) -}
4c43ce544bacc80471ed30ee30e1adf0
  $fMonoidFirst' :: GHC.Base.Monoid (Lib.First' a)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (Lib.First' a)
                  (Lib.Nada @ a) `cast` (Sym (Lib.N:First'[0]) <a>_N)
                  (Lib.$fMonoidFirst'_$cmappend @ a)
                  (Lib.$fMonoidFirst'_$cmconcat @ a) -}
4c43ce544bacc80471ed30ee30e1adf0
  $fMonoidFirst'1 :: [Lib.First' a] -> Lib.First' a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
4c43ce544bacc80471ed30ee30e1adf0
  $fMonoidFirst'_$cmappend ::
    Lib.First' a -> Lib.First' a -> Lib.First' a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (ds :: Lib.First' a) (ds1 :: Lib.First' a) ->
                 case ds `cast` (Lib.N:First'[0] <a>_N) of wild {
                   Lib.Nada -> ds1
                   Lib.Only x
                   -> (Lib.Only @ a x) `cast` (Sym (Lib.N:First'[0]) <a>_N) }) -}
4c43ce544bacc80471ed30ee30e1adf0
  $fMonoidFirst'_$cmconcat :: [Lib.First' a] -> Lib.First' a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (eta :: [Lib.First' a]) ->
                 Lib.$fMonoidFirst'1 @ a eta) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fMonoidOptional ::
    GHC.Base.Monoid a => GHC.Base.Monoid (Lib.Optional a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dMonoid :: GHC.Base.Monoid a).
                  @ (Lib.Optional a)
                  (Lib.$fMonoidOptional_$cmempty @ a $dMonoid)
                  (Lib.$fMonoidOptional_$cmappend @ a $dMonoid)
                  (Lib.$fMonoidOptional_$cmconcat @ a $dMonoid) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fMonoidOptional1 :: Lib.Optional a
  {- Strictness: x -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fMonoidOptional_$cmappend ::
    GHC.Base.Monoid a =>
    Lib.Optional a -> Lib.Optional a -> Lib.Optional a
  {- Arity: 3, Strictness: <L,1*U(A,1*C1(C1(U)),A)><S,1*U><S,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Base.Monoid a)
                   (w1 :: Lib.Optional a)
                   (w2 :: Lib.Optional a) ->
                 case w1 of wild {
                   Lib.Nada
                   -> case w2 of wild1 {
                        Lib.Nada
                        -> case Lib.$fMonoidOptional1 ret_ty (Lib.Optional a) of {}
                        Lib.Only y -> Lib.Only @ a y }
                   Lib.Only x
                   -> case w2 of wild1 {
                        Lib.Nada -> Lib.Only @ a x
                        Lib.Only y -> Lib.Only @ a (GHC.Base.mappend @ a w x y) } }) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fMonoidOptional_$cmconcat ::
    GHC.Base.Monoid a => [Lib.Optional a] -> Lib.Optional a
  {- Arity: 2, Strictness: <L,U(A,C(C1(U)),A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dMonoid :: GHC.Base.Monoid a)
                   (eta :: [Lib.Optional a]) ->
                 letrec {
                   go :: [Lib.Optional a] -> Lib.Optional a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Lib.Optional a]) ->
                     case ds of wild {
                       [] -> Lib.Nada @ a
                       : y ys
                       -> case y of wild1 {
                            Lib.Nada
                            -> case go ys of wild2 {
                                 Lib.Nada
                                 -> case Lib.$fMonoidOptional1 ret_ty (Lib.Optional a) of {}
                                 Lib.Only y1 -> wild2 }
                            Lib.Only x
                            -> case go ys of wild2 {
                                 Lib.Nada -> wild1
                                 Lib.Only y1
                                 -> Lib.Only @ a (GHC.Base.mappend @ a $dMonoid x y1) } } }
                 } in
                 go eta) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fMonoidOptional_$cmempty :: GHC.Base.Monoid a => Lib.Optional a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a ($dMonoid :: GHC.Base.Monoid a) -> Lib.Nada @ a) -}
4c43ce544bacc80471ed30ee30e1adf0
  $fShowFirst' :: GHC.Show.Show a => GHC.Show.Show (Lib.First' a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Lib.First' a)
                  (Lib.$fShowFirst'_$cshowsPrec @ a $dShow)
                  (Lib.$fShowFirst'_$cshow @ a $dShow)
                  (Lib.$fShowFirst'_$cshowList @ a $dShow) -}
239b78d78bc65fc357e1b0128597a030
  $fShowFirst'1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
be0d856061c6bcf20c7dc2d1c17abac0
  $fShowFirst'10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Lib.$fShowFirst'8
                   Lib.$fShowFirst'9) -}
850121d1f0d165d3a5cf10bd6a6e44b9
  $fShowFirst'2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
71e952cde9d62bf017161ee771815549
  $fShowFirst'3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getFirst' = "#) -}
bbfabff0acd251c7d5608d9d5147d933
  $fShowFirst'4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "First' {"#) -}
6b25a3921cfed54b5e3ec5bd48405417
  $fShowFirst'5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Only "#) -}
37e3a4be1c9f6f5ecdb188a26290911f
  $fShowFirst'6 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
03c10d9e8b45cdf9c1453d62af47bd91
  $fShowFirst'7 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Lib.$fShowFirst'8) -}
50a7b250e9077185f6f69ac2aca90a1d
  $fShowFirst'8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Nada"#) -}
a2fdf61ac5f55a4c47c0f116b1a2a30d
  $fShowFirst'9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Lib.$fShowFirst'2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4c43ce544bacc80471ed30ee30e1adf0
  $fShowFirst'_$cshow ::
    GHC.Show.Show a => Lib.First' a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Lib.First' a) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Lib.$fShowFirst'4
                   (GHC.Base.++
                      @ GHC.Types.Char
                      Lib.$fShowFirst'3
                      (case x `cast` (Lib.N:First'[0] <a>_N) of wild {
                         Lib.Nada -> Lib.$fShowFirst'10
                         Lib.Only b1
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              Lib.$fShowFirst'5
                              (GHC.Show.showsPrec
                                 @ a
                                 $dShow
                                 Lib.$fShowFirst'6
                                 b1
                                 Lib.$fShowFirst'9) }))) -}
4c43ce544bacc80471ed30ee30e1adf0
  $fShowFirst'_$cshowList ::
    GHC.Show.Show a => [Lib.First' a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Lib.First' a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Lib.First' a)
                   (Lib.$fShowFirst'_$cshowsPrec @ a $dShow Lib.$fShowFirst'1)
                   eta
                   eta1) -}
4c43ce544bacc80471ed30ee30e1adf0
  $fShowFirst'_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Lib.First' a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><L,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Lib.First' a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Lib.$w$cshowsPrec @ a w ww1 w2 }) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fShowFirst'_$cshowsPrec1 ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Lib.Optional a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (ds1 :: Lib.Optional a) ->
                 case ds1 of wild {
                   Lib.Nada -> Lib.$fShowFirst'7
                   Lib.Only b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a $dShow Lib.$fShowFirst'6 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Lib.$fShowFirst'5 (g x1)
                        GHC.Types.True
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Lib.$fShowFirst'5
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x1))) } } }) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fShowOptional :: GHC.Show.Show a => GHC.Show.Show (Lib.Optional a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Lib.Optional a)
                  (Lib.$fShowFirst'_$cshowsPrec1 @ a $dShow)
                  (Lib.$fShowOptional_$cshow @ a $dShow)
                  (Lib.$fShowOptional_$cshowList @ a $dShow) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fShowOptional_$cshow ::
    GHC.Show.Show a => Lib.Optional a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Lib.Optional a) ->
                 case x of wild {
                   Lib.Nada -> Lib.$fShowFirst'8
                   Lib.Only b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lib.$fShowFirst'5
                        (GHC.Show.showsPrec
                           @ a
                           $dShow
                           Lib.$fShowFirst'6
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
d997638d7c2f8fb47aeb6ed74ca47d86
  $fShowOptional_$cshowList ::
    GHC.Show.Show a => [Lib.Optional a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Lib.Optional a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Lib.Optional a)
                   (Lib.$fShowFirst'_$cshowsPrec1 @ a $dShow Lib.$fShowFirst'1)
                   eta
                   eta1) -}
18d1a09581fdc2521058a344828c5e8d
  $tc'First' :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7970092390700820815##
                   3312192375823576842##
                   Lib.$trModule
                   Lib.$tc'First'1) -}
88e96635c386d0924a0cd3297d497994
  $tc'First'1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'First'"#) -}
fb42eea6a89f677d117fccd0a1f93c88
  $tc'Nada :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1481141935214461464##
                   2559602046522213224##
                   Lib.$trModule
                   Lib.$tc'Nada1) -}
7352e8145cbf0cd7f08ddc1f0ca52c21
  $tc'Nada1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Nada"#) -}
6b90871fb8817c87fef277fde02a6bb2
  $tc'Only :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   836287261981152598##
                   8523385153553610804##
                   Lib.$trModule
                   Lib.$tc'Only1) -}
fa43dac66162aae67c7072979007d4a3
  $tc'Only1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Only"#) -}
30f6989d321f9e26daaaae8bea76ce5f
  $tcFirst' :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17446137895165600793##
                   2479258227796749640##
                   Lib.$trModule
                   Lib.$tcFirst'1) -}
a5ff5ae10e9fa61e5891f590e31c31d6
  $tcFirst'1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "First'"#) -}
1950de3e1e81b9056b7b9552be990e24
  $tcOptional :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8743987047305705609##
                   11207643301964163436##
                   Lib.$trModule
                   Lib.$tcOptional1) -}
6f418b33ec6ecedfcd09b37a2cf28b49
  $tcOptional1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Optional"#) -}
f7818afa81659275a99c1bda6727fcbf
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
a9ab4a111ac214fdc24f1612b499f0df
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
dd0dc05a585acf0785390e823390db9d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "chapter15-0.1.0.0-Jcnq64q4x8L3hVPjY2Ehph"#) -}
4c43ce544bacc80471ed30ee30e1adf0
  $w$cshowsPrec ::
    GHC.Show.Show a => GHC.Prim.Int# -> Lib.First' a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Lib.First' a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Lib.$fShowFirst'_$cshowsPrec1
                       @ a
                       w
                       Lib.$fShowFirst'1
                       w1 `cast` (Lib.N:First'[0] <a>_N)
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Lib.$fShowFirst'4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Lib.$fShowFirst'3
                          (f (GHC.Base.++ @ GHC.Types.Char Lib.$fShowFirst'2 x)))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
4c43ce544bacc80471ed30ee30e1adf0
  newtype First' a = First' {getFirst' :: Lib.Optional a}
d997638d7c2f8fb47aeb6ed74ca47d86
  data Optional a = Nada | Only a
aa4964a618840dbb9cf81870692dba8f
  getFirst' :: Lib.First' a -> Lib.Optional a
  RecSel Left Lib.First'
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Lib.getFirst'1
                  `cast`
                (forall (a :: <*>_N).
                 <Lib.First' a>_R ->_R Lib.N:First'[0] <a>_N) -}
12081809b9a1c7e9c1e6375049e4e1bb
  getFirst'1 :: Lib.First' a -> Lib.First' a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: Lib.First' a) -> ds) -}
e0a344d44aab6735c85f088143d297d0
  someFunc :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.someFunc1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
72bd4e8a5ee920dbf69641bdafc9fa8f
  someFunc1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (eta :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   Lib.someFunc2
                   GHC.Types.True
                   eta) -}
c92c7bb23593c571dd10097a046ed139
  someFunc2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "someFunc"#) -}
instance [safe] GHC.Classes.Eq [Lib.First'] = Lib.$fEqFirst'
instance [safe] GHC.Classes.Eq [Lib.Optional] = Lib.$fEqOptional
instance [safe] GHC.Base.Monoid [Lib.First'] = Lib.$fMonoidFirst'
instance [safe] GHC.Base.Monoid [Lib.Optional]
  = Lib.$fMonoidOptional
instance [safe] GHC.Show.Show [Lib.First'] = Lib.$fShowFirst'
instance [safe] GHC.Show.Show [Lib.Optional] = Lib.$fShowOptional
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

